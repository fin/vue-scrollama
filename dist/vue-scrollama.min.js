var VueScrollama = function () {
  "use strict";

  function e(e) {
    for (var t = e.length, n = [], i = 0; i < t; i += 1) n.push(e[i]);
    return n
  }

  function t(e) {
    return "scrollama__debug-offset--" + e.id
  }

  function n(e) {
    !function (e) {
      var n = e.id, i = e.offsetVal, o = e.stepClass, r = document.createElement("div");
      r.setAttribute("id", t({id: n})), r.setAttribute("class", "scrollama__debug-offset"), r.style.position = "fixed", r.style.left = "0", r.style.width = "100%", r.style.height = "0px", r.style.borderTop = "2px dashed black", r.style.zIndex = "9999";
      var s = document.createElement("p");
      s.innerText = '".' + o + '" trigger: ' + i, s.style.fontSize = "12px", s.style.fontFamily = "monospace", s.style.color = "black", s.style.margin = "0", s.style.padding = "6px", r.appendChild(s), document.body.appendChild(r)
    }({id: e.id, offsetVal: e.offsetVal, stepClass: e.stepEl[0].getAttribute("class")})
  }

  function i(e) {
    var n = e.id, i = (e.stepOffsetHeight, e.offsetMargin);
    e.offsetVal;
    !function (e) {
      var n = e.id, i = e.offsetMargin, o = (e.offsetVal, t({id: n}));
      document.querySelector("#" + o).style.top = i + "px"
    }({id: n, offsetMargin: i})
  }

  function o(e) {
    var t = e.id, n = e.index, i = e.state, o = function (e) {
        return "scrollama__debug-step--" + e.id + "-" + e.i
      }({id: t, i: n}), r = document.querySelector("#" + o + "_above"), s = document.querySelector("#" + o + "_below"),
      a = "enter" === i ? "block" : "none";
    r && (r.style.display = a), s && (s.style.display = a)
  }

  function r() {
    var t = ["stepAbove", "stepBelow", "stepProgress", "viewportAbove", "viewportBelow"], r = {
        stepEnter: function () {
        }, stepExit: function () {
        }, stepProgress: function () {
        }
      }, s = {}, a = null, l = [], f = [], c = [], d = [], u = 0, p = 0, h = 0, g = 0, v = 0, m = 0, b = !1, _ = !1,
      y = !1, w = !1, x = !1, E = !1, O = "down", T = [];

    function k(e) {
      return e.getBoundingClientRect().top + window.pageYOffset - (document.body.clientTop || 0)
    }

    function R(e) {
      return +e.getAttribute("data-scrollama-index")
    }

    function S() {
      window.pageYOffset > v ? O = "down" : window.pageYOffset < v && (O = "up"), v = window.pageYOffset
    }

    function C(e) {
      s[e] && s[e].forEach((function (e) {
        return e.disconnect()
      }))
    }

    function M() {
      var e, t;
      h = window.innerHeight, e = document.body, t = document.documentElement, g = Math.max(e.scrollHeight, e.offsetHeight, t.clientHeight, t.scrollHeight, t.offsetHeight), p = u * h, b && (f = l.map((function (e) {
        return e.getBoundingClientRect().height
      })), c = l.map(k), _ && j()), y && i({id: a, stepOffsetHeight: f, offsetMargin: p, offsetVal: u})
    }

    function $(e) {
      if (e && !_) {
        if (!b) return console.error("scrollama error: enable() called before scroller was ready"), void (_ = !1);
        j()
      }
      !e && _ && t.forEach(C), _ = e
    }

    function H(e, t) {
      var n = R(e);
      void 0 !== t && (d[n].progress = t);
      var i = {element: e, index: n, progress: d[n].progress};
      "enter" === d[n].state && r.stepProgress(i)
    }

    function z(e, t) {
      if ("above" === t) for (var n = 0; n < e; n++) {
        var i = d[n];
        "enter" !== i.state && "down" !== i.direction ? (A(l[n], "down", !1), L(l[n], "down")) : "enter" === i.state && L(l[n], "down")
      } else if ("below" === t) for (var o = d.length - 1; o > e; o--) {
        var r = d[o];
        "enter" === r.state && L(l[o], "up"), "down" === r.direction && (A(l[o], "up", !1), L(l[o], "up"))
      }
    }

    function A(e, t, n) {
      void 0 === n && (n = !0);
      var i = R(e), s = {element: e, index: i, direction: t};
      d[i].direction = t, d[i].state = "enter", x && n && "down" === t && z(i, "above"), x && n && "up" === t && z(i, "below"), r.stepEnter && !T[i] && (r.stepEnter(s, d), y && o({
        id: a,
        index: i,
        state: "enter"
      }), E && (T[i] = !0)), w && H(e)
    }

    function L(e, t) {
      var n = R(e), i = {element: e, index: n, direction: t};
      w && ("down" === t && d[n].progress < 1 ? H(e, 1) : "up" === t && d[n].progress > 0 && H(e, 0)), d[n].direction = t, d[n].state = "exit", r.stepExit(i, d), y && o({
        id: a,
        index: n,
        state: "exit"
      })
    }

    function P(e) {
      var t = e[0];
      S();
      var n = t.isIntersecting, i = t.boundingClientRect, o = t.target, r = i.top, s = i.bottom, a = r - p, l = s - p,
        f = R(o), c = d[f];
      n && a <= 0 && l >= 0 && "down" === O && "enter" !== c.state && A(o, O), !n && a > 0 && "up" === O && "enter" === c.state && L(o, O)
    }

    function I(e) {
      var t = e[0];
      S();
      var n = t.isIntersecting, i = t.boundingClientRect, o = t.target, r = i.top, s = i.bottom, a = r - p, l = s - p,
        f = R(o), c = d[f];
      n && a <= 0 && l >= 0 && "up" === O && "enter" !== c.state && A(o, O), !n && l < 0 && "down" === O && "enter" === c.state && L(o, O)
    }

    function F(e) {
      var t = e[0];
      S();
      var n = t.isIntersecting, i = t.target, o = R(i), r = d[o];
      n && "down" === O && "down" !== r.direction && "enter" !== r.state && (A(i, "down"), L(i, "down"))
    }

    function V(e) {
      var t = e[0];
      S();
      var n = t.isIntersecting, i = t.target, o = R(i), r = d[o];
      n && "up" === O && "down" === r.direction && "enter" !== r.state && (A(i, "up"), L(i, "up"))
    }

    function B(e) {
      var t = e[0];
      S();
      var n = t.isIntersecting, i = t.intersectionRatio, o = t.boundingClientRect, r = t.target, s = o.bottom;
      n && s - p >= 0 && H(r, +i.toFixed(3))
    }

    function N() {
      s.stepProgress = l.map((function (e, t) {
        var n = f[t] - p + "px 0px " + (-h + p) + "px 0px", i = function (e) {
          for (var t = Math.ceil(e / m), n = [], i = 1 / t, o = 0; o < t; o++) n.push(o * i);
          return n
        }(f[t]), o = new IntersectionObserver(B, {rootMargin: n, threshold: i});
        return o.observe(e), o
      }))
    }

    function j() {
      t.forEach(C), s.viewportAbove = l.map((function (e, t) {
        var n = g - c[t], i = p - h - f[t], o = new IntersectionObserver(F, {rootMargin: n + "px 0px " + i + "px 0px"});
        return o.observe(e), o
      })), s.viewportBelow = l.map((function (e, t) {
        var n = -p - f[t], i = p - h + f[t] + g,
          o = new IntersectionObserver(V, {rootMargin: n + "px 0px " + i + "px 0px"});
        return o.observe(e), o
      })), s.stepAbove = l.map((function (e, t) {
        var n = -p + f[t], i = new IntersectionObserver(P, {rootMargin: n + "px 0px " + (p - h) + "px 0px"});
        return i.observe(e), i
      })), s.stepBelow = l.map((function (e, t) {
        var n = -p, i = p - h + f[t], o = new IntersectionObserver(I, {rootMargin: n + "px 0px " + i + "px 0px"});
        return o.observe(e), o
      })), w && N()
    }

    var W = {};
    return W.setup = function (t) {
      var i = t.step, o = t.offset;
      void 0 === o && (o = .5);
      var r = t.progress;
      void 0 === r && (r = !1);
      var s = t.threshold;
      void 0 === s && (s = 4);
      var f = t.debug;
      void 0 === f && (f = !1);
      var c = t.order;
      void 0 === c && (c = !0);
      var p, h, g, v, _, O = t.once;
      return void 0 === O && (O = !1), h = (p = "abcdefghijklmnopqrstuv").length, g = Date.now(), a = "" + [0, 0, 0].map((function (e) {
        return p[Math.floor(Math.random() * h)]
      })).join("") + g, v = i, void 0 === _ && (_ = document), (l = "string" == typeof v ? e(_.querySelectorAll(v)) : v instanceof Element ? e([v]) : v instanceof NodeList ? e(v) : v instanceof Array ? v : []).length ? (y = f, w = r, x = c, E = O, W.offsetTrigger(o), m = Math.max(1, +s), b = !0, y && n({
        id: a,
        stepEl: l,
        offsetVal: u
      }), l.forEach((function (e, t) {
        return e.setAttribute("data-scrollama-index", t)
      })), d = l.map((function () {
        return {direction: null, state: null, progress: 0}
      })), M(), W.enable(), W) : (console.error("scrollama error: no step elements"), W)
    }, W.resize = function () {
      return M(), W
    }, W.enable = function () {
      return $(!0), W
    }, W.disable = function () {
      return $(!1), W
    }, W.destroy = function () {
      $(!1), Object.keys(r).forEach((function (e) {
        return r[e] = null
      })), Object.keys(s).forEach((function (e) {
        return s[e] = null
      }))
    }, W.offsetTrigger = function (e) {
      return e && !isNaN(e) ? (e > 1 && console.error("scrollama error: offset value is greater than 1. Fallbacks to 1."), e < 0 && console.error("scrollama error: offset value is lower than 0. Fallbacks to 0."), u = Math.min(Math.max(0, e), 1), W) : (isNaN(e) && console.error("scrollama error: offset value is not a number. Fallbacks to 0."), u)
    }, W.onStepEnter = function (e) {
      return "function" == typeof e ? r.stepEnter = e : console.error("scrollama error: onStepEnter requires a function"), W
    }, W.onStepExit = function (e) {
      return "function" == typeof e ? r.stepExit = e : console.error("scrollama error: onStepExit requires a function"), W
    }, W.onStepProgress = function (e) {
      return "function" == typeof e ? r.stepProgress = e : console.error("scrollama error: onStepProgress requires a function"), W
    }, W
  }

  var s = void 0;

  function a() {
    a.init || (a.init = !0, s = -1 !== function () {
      var e = window.navigator.userAgent, t = e.indexOf("MSIE ");
      if (t > 0) return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
      if (e.indexOf("Trident/") > 0) {
        var n = e.indexOf("rv:");
        return parseInt(e.substring(n + 3, e.indexOf(".", n)), 10)
      }
      var i = e.indexOf("Edge/");
      return i > 0 ? parseInt(e.substring(i + 5, e.indexOf(".", i)), 10) : -1
    }())
  }

  var l = {
    render: function () {
      var e = this.$createElement;
      return (this._self._c || e)("div", {staticClass: "resize-observer", attrs: {tabindex: "-1"}})
    },
    staticRenderFns: [],
    _scopeId: "data-v-b329ee4c",
    name: "resize-observer",
    methods: {
      compareAndNotify: function () {
        this._w === this.$el.offsetWidth && this._h === this.$el.offsetHeight || (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.$emit("notify"))
      }, addResizeHandlers: function () {
        this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify()
      }, removeResizeHandlers: function () {
        this._resizeObject && this._resizeObject.onload && (!s && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), delete this._resizeObject.onload)
      }
    },
    mounted: function () {
      var e = this;
      a(), this.$nextTick((function () {
        e._w = e.$el.offsetWidth, e._h = e.$el.offsetHeight
      }));
      var t = document.createElement("object");
      this._resizeObject = t, t.setAttribute("aria-hidden", "true"), t.setAttribute("tabindex", -1), t.onload = this.addResizeHandlers, t.type = "text/html", s && this.$el.appendChild(t), t.data = "about:blank", s || this.$el.appendChild(t)
    },
    beforeDestroy: function () {
      this.removeResizeHandlers()
    }
  };
  var f = {
    version: "0.4.5", install: function (e) {
      e.component("resize-observer", l), e.component("ResizeObserver", l)
    }
  }, c = null;
  "undefined" != typeof window ? c = window.Vue : "undefined" != typeof global && (c = global.Vue), c && c.use(f);
  var d = function (e, t) {
    return e(t = {exports: {}}, t.exports), t.exports
  }((function (e) {
    !function (t, n) {
      var i = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
          }
        }

        return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t
        }
      }();
      var o, r = !1, s = void 0 !== t;
      s && t.getComputedStyle ? (o = n.createElement("div"), ["", "-webkit-", "-moz-", "-ms-"].some((function (e) {
        try {
          o.style.position = e + "sticky"
        } catch (e) {
        }
        return "" != o.style.position
      })) && (r = !0)) : r = !0;
      var a = !1, l = "undefined" != typeof ShadowRoot, f = {top: null, left: null}, c = [];

      function d(e, t) {
        for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
      }

      function u(e) {
        return parseFloat(e) || 0
      }

      function p(e) {
        for (var t = 0; e;) t += e.offsetTop, e = e.offsetParent;
        return t
      }

      var h = function () {
        function e(t) {
          if (function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
          }(this, e), !(t instanceof HTMLElement)) throw new Error("First argument must be HTMLElement");
          if (c.some((function (e) {
            return e._node === t
          }))) throw new Error("Stickyfill is already applied to this node");
          this._node = t, this._stickyMode = null, this._active = !1, c.push(this), this.refresh()
        }

        return i(e, [{
          key: "refresh", value: function () {
            if (!r && !this._removed) {
              this._active && this._deactivate();
              var e = this._node, i = getComputedStyle(e), o = {
                position: i.position,
                top: i.top,
                display: i.display,
                marginTop: i.marginTop,
                marginBottom: i.marginBottom,
                marginLeft: i.marginLeft,
                marginRight: i.marginRight,
                cssFloat: i.cssFloat
              };
              if (!isNaN(parseFloat(o.top)) && "table-cell" != o.display && "none" != o.display) {
                this._active = !0;
                var s = e.style.position;
                "sticky" != i.position && "-webkit-sticky" != i.position || (e.style.position = "static");
                var a = e.parentNode, f = l && a instanceof ShadowRoot ? a.host : a, c = e.getBoundingClientRect(),
                  h = f.getBoundingClientRect(), g = getComputedStyle(f);
                this._parent = {
                  node: f,
                  styles: {position: f.style.position},
                  offsetHeight: f.offsetHeight
                }, this._offsetToWindow = {
                  left: c.left,
                  right: n.documentElement.clientWidth - c.right
                }, this._offsetToParent = {
                  top: c.top - h.top - u(g.borderTopWidth),
                  left: c.left - h.left - u(g.borderLeftWidth),
                  right: -c.right + h.right - u(g.borderRightWidth)
                }, this._styles = {
                  position: s,
                  top: e.style.top,
                  bottom: e.style.bottom,
                  left: e.style.left,
                  right: e.style.right,
                  width: e.style.width,
                  marginTop: e.style.marginTop,
                  marginLeft: e.style.marginLeft,
                  marginRight: e.style.marginRight
                };
                var v = u(o.top);
                this._limits = {
                  start: c.top + t.pageYOffset - v,
                  end: h.top + t.pageYOffset + f.offsetHeight - u(g.borderBottomWidth) - e.offsetHeight - v - u(o.marginBottom)
                };
                var m = g.position;
                "absolute" != m && "relative" != m && (f.style.position = "relative"), this._recalcPosition();
                var b = this._clone = {};
                b.node = n.createElement("div"), d(b.node.style, {
                  width: c.right - c.left + "px",
                  height: c.bottom - c.top + "px",
                  marginTop: o.marginTop,
                  marginBottom: o.marginBottom,
                  marginLeft: o.marginLeft,
                  marginRight: o.marginRight,
                  cssFloat: o.cssFloat,
                  padding: 0,
                  border: 0,
                  borderSpacing: 0,
                  fontSize: "1em",
                  position: "static"
                }), a.insertBefore(b.node, e), b.docOffsetTop = p(b.node)
              }
            }
          }
        }, {
          key: "_recalcPosition", value: function () {
            if (this._active && !this._removed) {
              var e = f.top <= this._limits.start ? "start" : f.top >= this._limits.end ? "end" : "middle";
              if (this._stickyMode != e) {
                switch (e) {
                  case"start":
                    d(this._node.style, {
                      position: "absolute",
                      left: this._offsetToParent.left + "px",
                      right: this._offsetToParent.right + "px",
                      top: this._offsetToParent.top + "px",
                      bottom: "auto",
                      width: "auto",
                      marginLeft: 0,
                      marginRight: 0,
                      marginTop: 0
                    });
                    break;
                  case"middle":
                    d(this._node.style, {
                      position: "fixed",
                      left: this._offsetToWindow.left + "px",
                      right: this._offsetToWindow.right + "px",
                      top: this._styles.top,
                      bottom: "auto",
                      width: "auto",
                      marginLeft: 0,
                      marginRight: 0,
                      marginTop: 0
                    });
                    break;
                  case"end":
                    d(this._node.style, {
                      position: "absolute",
                      left: this._offsetToParent.left + "px",
                      right: this._offsetToParent.right + "px",
                      top: "auto",
                      bottom: 0,
                      width: "auto",
                      marginLeft: 0,
                      marginRight: 0
                    })
                }
                this._stickyMode = e
              }
            }
          }
        }, {
          key: "_fastCheck", value: function () {
            this._active && !this._removed && (Math.abs(p(this._clone.node) - this._clone.docOffsetTop) > 1 || Math.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1) && this.refresh()
          }
        }, {
          key: "_deactivate", value: function () {
            var e = this;
            this._active && !this._removed && (this._clone.node.parentNode.removeChild(this._clone.node), delete this._clone, d(this._node.style, this._styles), delete this._styles, c.some((function (t) {
              return t !== e && t._parent && t._parent.node === e._parent.node
            })) || d(this._parent.node.style, this._parent.styles), delete this._parent, this._stickyMode = null, this._active = !1, delete this._offsetToWindow, delete this._offsetToParent, delete this._limits)
          }
        }, {
          key: "remove", value: function () {
            var e = this;
            this._deactivate(), c.some((function (t, n) {
              if (t._node === e._node) return c.splice(n, 1), !0
            })), this._removed = !0
          }
        }]), e
      }(), g = {
        stickies: c, Sticky: h, forceSticky: function () {
          r = !1, v(), this.refreshAll()
        }, addOne: function (e) {
          if (!(e instanceof HTMLElement)) {
            if (!e.length || !e[0]) return;
            e = e[0]
          }
          for (var t = 0; t < c.length; t++) if (c[t]._node === e) return c[t];
          return new h(e)
        }, add: function (e) {
          if (e instanceof HTMLElement && (e = [e]), e.length) {
            for (var t = [], n = function (n) {
              var i = e[n];
              return i instanceof HTMLElement ? c.some((function (e) {
                if (e._node === i) return t.push(e), !0
              })) ? "continue" : void t.push(new h(i)) : (t.push(void 0), "continue")
            }, i = 0; i < e.length; i++) n(i);
            return t
          }
        }, refreshAll: function () {
          c.forEach((function (e) {
            return e.refresh()
          }))
        }, removeOne: function (e) {
          if (!(e instanceof HTMLElement)) {
            if (!e.length || !e[0]) return;
            e = e[0]
          }
          c.some((function (t) {
            if (t._node === e) return t.remove(), !0
          }))
        }, remove: function (e) {
          if (e instanceof HTMLElement && (e = [e]), e.length) for (var t = function (t) {
            var n = e[t];
            c.some((function (e) {
              if (e._node === n) return e.remove(), !0
            }))
          }, n = 0; n < e.length; n++) t(n)
        }, removeAll: function () {
          for (; c.length;) c[0].remove()
        }
      };

      function v() {
        if (!a) {
          a = !0, r(), t.addEventListener("scroll", r), t.addEventListener("resize", g.refreshAll), t.addEventListener("orientationchange", g.refreshAll);
          var e = void 0, i = void 0, o = void 0;
          "hidden" in n ? (i = "hidden", o = "visibilitychange") : "webkitHidden" in n && (i = "webkitHidden", o = "webkitvisibilitychange"), o ? (n[i] || s(), n.addEventListener(o, (function () {
            n[i] ? clearInterval(e) : s()
          }))) : s()
        }

        function r() {
          t.pageXOffset != f.left ? (f.top = t.pageYOffset, f.left = t.pageXOffset, g.refreshAll()) : t.pageYOffset != f.top && (f.top = t.pageYOffset, f.left = t.pageXOffset, c.forEach((function (e) {
            return e._recalcPosition()
          })))
        }

        function s() {
          e = setInterval((function () {
            c.forEach((function (e) {
              return e._fastCheck()
            }))
          }), 500)
        }
      }

      r || v(), e.exports ? e.exports = g : s && (t.Stickyfill = g)
    }(window, document)
  }));
  var u = function (e, t, n, i, o, r, s, a, l, f) {
    "boolean" != typeof s && (l = a, a = s, s = !1);
    var c, d = "function" == typeof n ? n.options : n;
    if (e && e.render && (d.render = e.render, d.staticRenderFns = e.staticRenderFns, d._compiled = !0, o && (d.functional = !0)), i && (d._scopeId = i), r ? (c = function (e) {
      (e = e || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (e = __VUE_SSR_CONTEXT__), t && t.call(this, l(e)), e && e._registeredComponents && e._registeredComponents.add(r)
    }, d._ssrRegister = c) : t && (c = s ? function () {
      t.call(this, f(this.$root.$options.shadowRoot))
    } : function (e) {
      t.call(this, a(e))
    }), c) if (d.functional) {
      var u = d.render;
      d.render = function (e, t) {
        return c.call(t), u(e, t)
      }
    } else {
      var p = d.beforeCreate;
      d.beforeCreate = p ? [].concat(p, c) : [c]
    }
    return n
  }({
    render: function () {
      var e = this, t = e.$createElement, n = e._self._c || t;
      return n("div", {
        staticClass: "scrollama-container",
        class: {"with-graphic": e.$slots.graphic},
        attrs: {id: "scrollama-container-" + e.id}
      }, [n("div", {
        ref: "scrollama-graphic",
        staticClass: "scrollama-graphic",
        attrs: {id: "scrollama-graphic-" + e.id}
      }, [e._t("graphic")], 2), e._v(" "), n("div", {
        staticClass: "scrollama-steps",
        attrs: {id: "scrollama-steps-" + e.id}
      }, [e._t("default")], 2), e._v(" "), n("resize-observer", {on: {notify: e.handleResize}})], 1)
    }, staticRenderFns: []
  }, void 0, {
    name: "Scrollama", components: {ResizeObserver: l}, props: {
      id: {
        type: String, validator: function (e) {
          return !/\s/.test(e)
        }, default: function () {
          return Math.random().toString(36).substr(2, 9)
        }
      }
    }, mounted: function () {
      d.add(this.$refs["scrollama-graphic"]), this.scroller = r(), this.setup()
    }, beforeDestroy: function () {
      this.scroller.destroy()
    }, computed: {
      opts: function () {
        return Object.assign({}, this.$attrs, {
          step: "#scrollama-steps-" + this.id + ">div",
          container: "#scrollama-container-" + this.id,
          graphic: "#scrollama-graphic-" + this.id
        })
      }
    }, methods: {
      setup: function () {
        var e = this;
        this.scroller.destroy(), this.scroller.setup(this.opts), this.$listeners["step-progress"] && this.scroller.onStepProgress((function (t) {
          e.$emit("step-progress", t)
        })), this.$listeners["step-enter"] && this.scroller.onStepEnter((function (t) {
          e.$emit("step-enter", t)
        })), this.$listeners["step-exit"] && this.scroller.onStepExit((function (t) {
          e.$emit("step-exit", t)
        })), this.$listeners["container-enter"] && this.scroller.onContainerEnter((function (t) {
          e.$emit("container-enter", t)
        })), this.$listeners["container-exit"] && this.scroller.onContainerExit((function (t) {
          e.$emit("container-exit", t)
        })), this.scroller.resize()
      }, handleResize: function () {
        this.scroller.resize()
      }
    }
  }, void 0, !1, void 0, void 0, void 0);
  return void 0 !== typeof Vue && Vue.component("Scrollama", u), u
}();
